<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*Связанный список это структура данных где несколько значений хранятся линейно
            Наиболее важной частью списка является структура узлов
            Каждый узел должен содержать некоторые данные и указывать на следующий узел в списке

            Узел имеет две части информации
            ссылка на следующий узел next
            значение узла value

            Также он будет содержать один метод - toString: который возвращает значение в строке

            Когда экземпляр класса linkedListNode сформирован, вызывается функция конструкто, чтобы
            инициализировать обьект с двумя свойствами 
        */
       class linkedListNode {
           constructor(value, next = null){
               this.value = value;
               this.next = next;
           }

           toString(callback){
               return callback ? callback(this.value) : `${this.value}`;
           }
    }
       class LinkedList{
           constructor(){
               this.head = null;
               this.tail = null;
           }
       }
       prepend(value){
        //создает новый узел, который  будет новым head
        //при создании передает второй аргумент, который указывает
        //что его 'next' будет текущий head.
        //так как его узел будет стоять перед текущим head.
       
       const newNode = new LinkedListNode(value, this.head);

       //Переназначаем head на новый узел
       this.head = newNode;

       //Если еще нет tail, делаем новый узел tail.
        if (!this.tail){
            this.tail = newNode;
        }

        //Возвращаем весь список
        return this;
    }
//Append метод принемает значения в качестве аргумента и создает новый узел с этим значением, помещая его в конец связанного списка.
        append(value){
            //создаем новый узел
            const newNode = new LinkedListNode(value);

            //Если нет head и tail делаем новым узлом head и tail.
            if (!this.head || !this.tail){
                this.head = newNode;
                this.tail = newNode;

                return this;
            }
        
        //Присоединяем новый узел к концу связонного списка
        //Берем последний узел и указываем, что его next будет новым узлом.
        this.tail.next = newNode;

        //переназначаем tail на новый узел.
        this.tail = newNode;

        return this;
        }
        
        //delete метод принемает значения в качестве аргумента, удаляет все узлы, которые имеют указанное значение и возращает последний удаленный узел.
        delete(value){
            //если нет head значит список пуст
            if (!this.head){
                return null;
            }

            let deletedNode = null;

            //Если head должен быть удален, то делаем следующий узел новым head.
            while (this.head && this.head.value === value){
                deletedNode = this.head;
            }

            //Переназначаем следующий за head узел на новый head.
            this.head = this.head.next;
        }

        let currentNode = this.head;

        //Если следующий узел должен быть удален 
        //Делаеи узел через один, следующим для проверки
        //Перебераем все узлы и удаляем их если их значение равно указанному.
        if(currentNode !==null){
            while(currentNode.next){
                if (currentNode.next.value === value){
                    deletedNode = currentNode.next;
                    //перезаписываем чтобы узел через один стал следующим узлом
                    currentNode.next = currentNode.next.next;
                }else{
                    currentNode = currentNode.next;
                }
            }
        }

    </script>

</body>
</html>
