<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //In this kata, you will create a simple, immutable, singly-linked list.
        //mutable
        
        //Проблемма перерезаписывании данных
        const a = [1,2,3];
        const b = a;
        b.push(4);
        console.log(a === b);//
        
        const c = {name: 'Alex'};
        const d = a;
        b.name = 'Julia';
        console.log(a.name);

        //immutable функция высшего порядка push

        const push = value => array => {
            const clone = [...array];
            clone.push(value);
            return clone;
        };
        
        const i = push(5)(a);
        console.log(i === a);

        //--Классы 
        class MyClass{
            //методы класса
            constructor() {}
            method1(){}
            method1(){}
            method1(){}
            method1(){}
        }
        class User {//класс это разновидность функции
            constructor(name){this.name = name;}
            sayHi(){console.log(this.name)}
        }
        /*создает функцию с именем user котора становистя результатом обьявления класса
        Код функции берется из метода constructor
        Сохраняется все методы, такие как sayHi в User.prototype
        */




        //Когда мы делаем обновление данных мы хотим совершенно новую структуру данных
        //Которая содержит все элементы предыдущего состаяния а также наши обнавления

        //метод push это мутация в массиве он изменяет все ссылки на тотже массив


        //--Прототипное наследование
        let animal = {
            eats: true,
            walk(){
                console.log('Animal Walk')
            }
        };
        let rabbit = {
            jumps: true,
            
            __proto__:animal//значение __proto__ может быть обьект или null
        };
        
        rabbit.__proto__= animal;
        console.log(rabbit.walk())//walk унаследованна у 
        /*сылки не могут идти по кругу
        может быть только 1 [[Prototype]].Обьект не может наследовать от двух других обьектов

        Операции записи не используют прототип
        Прототип используется только для чтения свойств
        Операции записи удаления работают только на прямую с обьектом
        */
       let animal2 = {
           eats:true,
           walk(){
               //этот метод не будет использоваться в rabbit
           }
       }
       let rabbit2 = {
           __proto__:animal2
       };

       rabbit.walk = function(){//добавить в обьект rabbit метод walk
           console.log('Rabbit! Bounce-Bounce!');
       };
       rabbit.walk();//Rabbit! Bounce-Bounce!


       //--F.prototype
       let animal3 = {
           eats: true
       };

       function Rabbit3(name){
           this.name = name;
       }

       Rabbit3.prototype = animal3;

       let rabbit4 = new Rabbit3('White Rabbit');// rabbit.__proto__== animal
       //Установка Rabbit.prototype = animal - при создании обьекта через new Rabbit() запшите ему animal в [[Prototype]]
       /*F.prototype используется только при вызове new f() и присваевается в качестве свойства [[Prototype]] нововго обьекта

       */
        // class mutableGlass{
        //     constructor(content, amount){
        //         this.content = content;
        //         this.amount = amount;
        //     }
        //     takeDink(value){
        //         this.amount = Math.max(this.amount - value, 0);
        //         return this;
        //     }
        // }
        // const mg1 = new MutableGlass('water', 100);
        // const mg2 = mg1.takeDink(20);
        // console.log(mg1 === mg2);
        // console.log(mg.amount === mg2.amount);
        //-----------------------------------------------------
        function List() {
            
        }

        function EmptyList() {}
        EmptyList.prototype = new List();
        EmptyList.prototype.constructor = EmptyList;

        EmptyList.prototype.toString = function(){}
    </script>

</body>
</html>
